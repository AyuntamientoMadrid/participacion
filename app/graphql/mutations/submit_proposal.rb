module Mutations
  class SubmitProposal < BaseMutation
    argument :title, String, required: true, validates: { allow_blank: false }
    argument :description, String, required: true, validates: { allow_blank: false }
    argument :summary, String, required: true, validates: {
      length: { maximum: 200 },
      allow_blank: false
    }
    argument :terms_of_service, Boolean, required: true

    argument :geozone_id, ID, required: false
    argument :video_url, String, required: false
    argument :tag_list, String, required: false

    class FileUploadAttributes < Types::BaseInputObject
      argument :title, String, required: true
      # The path here is generated by DirectUpload Class
      # actual file uploading happens via HTTP multipart in DirectUploadsController
      argument :file_path_on_server, String, required: true
    end
    argument :image, FileUploadAttributes, required: false
    argument :documents, [FileUploadAttributes], required: false

    class MapLocationAttributes < Types::BaseInputObject
      argument :latitude, Float, required: true
      argument :longitude, Float, required: true
      argument :zoom, Integer, required: true
    end
    argument :map_location, MapLocationAttributes, required: false

    type Types::ProposalType

    def resolve(args)
      begin
        proposal_args = {
          translations_attributes: {
            '0': {
              locale: context[:current_resource].locale,
              title: args[:title],
              description: args[:description],
              summary: args[:summary]
            }
          },
          terms_of_service: args[:terms_of_service],
          geozone_id: args[:geozone_id],
          tag_list: args[:tag_list],
          video_url: args[:video_url],
          author: context[:current_resource]
        }

        if args[:image].present?
          proposal_args.merge!({
            image_attributes: {
              user_id: context[:current_resource].id,
              cached_attachment: args[:image][:file_path_on_server],
              title: args[:image][:title]
            }
          })
        end

        if args[:documents].present?
          proposal_args.merge!({
            documents_attributes: args[:documents].map do |document_data|
              {
                user_id: context[:current_resource].id,
                cached_attachment: document_data[:file_path_on_server],
                title: document_data[:title]
              }
            end
          })
        end

        if args[:map_location].present?
        proposal_args.merge!({ map_location_attributes: args[:map_location].to_hash })
        end

        Proposal.create!(proposal_args)
      rescue ActiveRecord::RecordInvalid => e
        raise GraphQL::ExecutionError, e.message
      end
    end
  end
end
